"""
File: This module provides a decoder for the binary traces generated by the DynamoRIO backend

Copyright (C) Microsoft Corporation
SPDX-License-Identifier: MIT
"""

from enum import Enum
from typing import Any, Final, List, Literal, TypeAlias, Union, cast
from io import BufferedReader
import sys
import os

import numpy as np
import numpy.typing as npt
from cffi import FFI
from typing_extensions import get_args, assert_never

_MarkerType = Literal["T", "D"]

# ==================================================================================================
# Trace types
# ==================================================================================================
# NOTE: cffi is too slow for large files, so we have to rely on hardcoded numpy dtypes.
# TODO: add tests to ensure the numpy dtypes and constants below match trace.hpp


class TraceEntryType:
    """
    Enum used for the trace entry type, copied from trace.hpp
    """
    # NOTE: the constants below must match trace_entry_type_t in trace.hpp
    ENTRY_EOT = 0  # end of trace
    ENTRY_PC = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_EXCEPTION = 4
    ENTRY_IND = 5

    @classmethod
    def to_str(cls, entry_type: int) -> str:
        """ Convert entry type to string """
        # pylint: disable=too-many-return-statements
        if entry_type == cls.ENTRY_EOT:
            return "EOT"
        if entry_type == cls.ENTRY_PC:
            return "PC"
        if entry_type == cls.ENTRY_READ:
            return "READ"
        if entry_type == cls.ENTRY_WRITE:
            return "WRITE"
        if entry_type == cls.ENTRY_EXCEPTION:
            return "EXCEPTION"
        if entry_type == cls.ENTRY_IND:
            return "IND"
        return f"UNKNOWN({entry_type})"


# numpy dtype for trace entries
TraceEntryDType: Final[np.dtype] = np.dtype([
    ('addr', np.uint64),   # trace_entry_t.addr in trace.hpp
    ('size', np.uint16),       # trace_entry_t.size in trace.hpp
    ('type', np.uint8),        # trace_entry_t.type in trace.hpp
])

# Type alias for arrays of TraceEntryDType
TraceEntryArray: TypeAlias = npt.NDArray[np.void]


# ==================================================================================================
# Debug Trace types
# ==================================================================================================
# TODO: autogenerate from debug_trace.hpp
# NOTE: cffi cannot parse CPP constructs (e.g. enum classes, sdt::array) so we
#       need to manually adjust some of the fields.


class DebugTraceEntryType(Enum):
    """
    Enum used for the debug trace entry type, copied from debug_trace.hpp
    TODO: Cffi cannot parse enum classes, find a way to autogenerate from the header file
    """
    ENTRY_EOT = 0  # end of trace
    ENTRY_REG_DUMP = 1
    ENTRY_READ = 2
    ENTRY_WRITE = 3
    ENTRY_LOC = 4
    ENTRY_EXCEPTION = 5
    ENTRY_CHECKPOINT = 6
    ENTRY_ROLLBACK = 7
    ENTRY_ROLLBACK_STORE = 8
    ENTRY_REG_DUMP_EXTENDED = 9


_DEBUG_TRACE_ENTRY_T: Final[str] = "struct debug_trace_entry_t"
_DEBUG_TRACE_ENTRY_DEF: Final[str] = """
struct debug_trace_entry_t {
    // What does this entry contain
    uint8_t type;
    // Nested speculation (0 is architectural)
    uint8_t nesting_level;
    // Unused for now
    uint8_t padding[6]; // NOLINT

    // Union of all possible entry types
    union {
        // ENTRY_REG_DUMP
        struct {
            uint64_t xax;
            uint64_t xbx;
            uint64_t xcx;
            uint64_t xdx;
            uint64_t xsi;
            uint64_t xdi;
            uint64_t pc;
        } regs;
        // ENTRY_REG_EXTENDED
        struct {
            uint64_t rsp;
            uint64_t rbp;
            uint64_t flags;
            uint64_t r8;
            uint64_t r9;
            uint64_t r10;
            uint64_t r11;
        } regs_2;
        // ENTRY_MEM (read or write)
        struct {
            uint64_t address;
            uint64_t value;
            uint64_t size;
        } mem;
        // ENTRY_LOC (module name and offset, for disassembly)
        struct {
            uint64_t offset;
            char module_name[48]; // NOLINT
        } loc;
        // ENTRY_EXCEPTION
        struct {
            int signal;
            uint64_t address;
        } xcpt;
        // ENTRY_CHECKPOINT
        struct {
            uint64_t rollback_pc;
            uint64_t cur_window_size;
            size_t cur_store_log_size;
        } checkpoint;
        // ENTRY_ROLLBACK
        struct {
            unsigned nesting;
            uint64_t rollback_pc;
        } rollback;
        // ENTRY_ROLLBACK_STORE
        struct {
            uint64_t addr;
            uint64_t val;
            size_t size;
            uint64_t nesting_level;
        } rollback_store;
    };
};
"""


# ==================================================================================================
# Decoder
# ==================================================================================================
class TraceDecoder:
    """
    This class provides a unified API for decoding trace entries
    """

    _ffi: FFI
    _trace_entry_size: int
    _debug_trace_entry_size: int

    def __init__(self) -> None:
        self._marker_size = 8  # 1 byte marker + 7 bytes padding
        self._trace_entry_size = TraceEntryDType.itemsize
        # Parse debug trace defs
        self._ffi = FFI()
        self._ffi.cdef(_DEBUG_TRACE_ENTRY_DEF)
        self._debug_trace_entry_size = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)

    # ----------------------------------------------------------------------------------------------
    # Public API
    # ----------------------------------------------------------------------------------------------
    def read_trace_marker(self, f: BufferedReader) -> Union[_MarkerType, Literal[""]]:
        """
        Get the type of the trace file.
        """
        marker = f.read(1).decode('utf-8')
        if len(marker) == 0:
            return ""
        assert marker in get_args(_MarkerType), f"Unknown trace type marker: {marker}"
        f.read(7)  # skip padding bytes
        return cast(_MarkerType, marker)

    def decode_trace_file(self, file: str) -> TraceEntryArray:
        """ Read a set of traces from a file. """
        file_size = os.stat(file).st_size
        num_entries = (file_size - self._marker_size) // self._trace_entry_size
        if num_entries <= 0:
            return np.empty((0,), dtype=TraceEntryDType)
        traces = np.fromfile(file, dtype=TraceEntryDType,
                             count=num_entries, offset=self._marker_size)
        return traces

    def decode_debug_trace_file(self, file: str) -> List[List[Any]]:
        """ Read a debug trace from a file. """
        with open(file, "rb") as f:
            marker = self.read_trace_marker(f)
            if marker == "":  # empty file
                return []
            assert marker == "D", f"Expected Debug trace (D), got {marker}"

            # Read the traces
            traces = []
            eof = False
            while not eof:

                entries = []
                while True:
                    # Read one entry
                    chunk = f.read(self._debug_trace_entry_size)
                    if len(chunk) < self._debug_trace_entry_size:
                        eof = True
                        break  # no more bytes to read: exit

                    # Decode it
                    entry = self._decode_debug_trace_entry(chunk)
                    entries.append(entry)

                    # If we reached EOT, move on to the next trace
                    if DebugTraceEntryType(entry.type) == DebugTraceEntryType.ENTRY_EOT:
                        traces.append(entries)
                        break

                # Check that the last trace ended with an EOT or EXCEPTION entry
                if eof and len(entries) > 0:
                    last_entry = entries[-1]
                    if DebugTraceEntryType(last_entry.type) != DebugTraceEntryType.ENTRY_EOT:
                        raise ValueError("Trace file does not end with an EOT entry")

        return traces

    def is_trace_corrupted(self, trace_path: str) -> bool:
        """
        Check if a trace ends with an EOT or EXCEPTION entry.
        """
        # Handle empty and non-existing traces as corrupted
        if not os.path.exists(trace_path) or os.stat(trace_path).st_size == 0:
            return True

        with open(trace_path, "rb") as f:
            trace_type = self.read_trace_marker(f)
            if trace_type == "":
                return True

            # Decode based on the type
            if trace_type == "T":
                entry_sz = self._trace_entry_size
                if os.stat(trace_path).st_size < entry_sz:
                    return True

                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_entry = np.frombuffer(f.read(entry_sz), dtype=TraceEntryDType)[0]

                # Check its type
                return bool(last_entry['type'] != TraceEntryType.ENTRY_EOT)

            if trace_type == "D":
                entry_sz = self._ffi.sizeof(_DEBUG_TRACE_ENTRY_T)
                if os.stat(trace_path).st_size < entry_sz:
                    return True

                # Decode last entry
                f.seek(-entry_sz, os.SEEK_END)
                last_dbg_entry = self._decode_debug_trace_entry(f.read(entry_sz))

                # Check its type
                last_dbg_entry_type = DebugTraceEntryType(last_dbg_entry.type)
                return last_dbg_entry_type != DebugTraceEntryType.ENTRY_EOT

            assert_never(trace_type)

    # ----------------------------------------------------------------------------------------------
    # Private API
    # ----------------------------------------------------------------------------------------------
    def _decode_debug_trace_entry(self, chunk: bytes) -> Any:
        """
        Decode a single debug entry from a chunk of bytes
        """
        # Decode it with ffi
        entry: Any = self._ffi.new(_DEBUG_TRACE_ENTRY_T + "*")
        self._ffi.memmove(entry, chunk, self._debug_trace_entry_size)

        # Check that the entry type is valid
        try:
            DebugTraceEntryType(entry.type)
        except Exception:
            raise ValueError(f"Error: Unknown debug entry type {str(entry.type)}")

        return entry


def main() -> None:
    """ Standalone decoding interface: pretty-print trace entries from a file """
    if len(sys.argv) != 2:
        print(f"Usage {sys.argv[0]} <TRACE_PATH>")
        sys.exit(1)

    # 1. Create decoder
    decoder = TraceDecoder()

    # 2. Decode file
    with open(sys.argv[1], "rb") as f:
        trace_type = decoder.read_trace_marker(f)
    if trace_type == "":
        print(f"Empty trace file: {sys.argv[1]}")
        sys.exit(1)
    if trace_type == "T":
        parsed_traces = decoder.decode_trace_file(sys.argv[1])
    elif trace_type == "D":
        print("Only leakage traces allowed: found debug traces instead")
        sys.exit(1)
    else:
        assert_never(trace_type)

    # Check that the input contains leakage traces
    if len(parsed_traces) == 0:
        print(f"No traces found in {sys.argv[1]}")
        sys.exit(1)

    # 3. Print all entries
    for entry in parsed_traces:
        type_name = TraceEntryType.to_str(entry['type'])
        print(f"[{type_name}] {hex(entry['addr'])}")


if __name__ == '__main__':
    main()
